#!/usr/bin/env python3
##
## EPITECH PROJECT, 2021
## 103cipher
## File description:
## cipher
##

from math import ceil, sqrt
from sys import argv


class Matrix:
    def __init__(self, rows, cols):
        self.storage = (rows * cols) * [0]
        self.rows = rows
        self.cols = cols

    def fill(self, msg):
        for i in range(len(msg)):
            self.storage[i] = ord(msg[i])

    def transposed(self):
        result = Matrix(self.cols, self.rows)
        for row in range(self.rows):
            for col in range(self.cols):
                result[col, row] = self[row, col]
        return result

    def determinant(self) -> int:
        assert(self.rows == self.cols)
        if self.rows == 1:
            return self.storage[0]
        elif self.rows == 2:
            return self[0, 0] * self[1, 1] - self[0, 1] * self[1, 0]
        elif self.rows >= 3:
            sum = 0
            for i in range(self.rows):
                sum += self[0, i] * self.cofactor(0, i)
            return sum

    def inverse(self):
        assert(self.rows == self.cols)
        result = Matrix(self.rows, self.cols)
        if self.rows == 1:
            result[0, 0] = 1 / self[0, 0]
        elif self.rows == 2:
            det = self.determinant()
            if det == 0:
                return None
            result[0, 0] = self[1, 1] / det
            result[0, 1] = -self[0, 1] / det
            result[1, 0] = -self[1, 0] / det
            result[1, 1] = self[0, 0] / det
        elif self.rows >= 3:
            for row in range(self.rows):
                for col in range(self.cols):
                    result[row, col] = self.cofactor(row, col)
            det = self.determinant()
            if det == 0:
                return None
            result = result.transposed() / det
        return result

    def cofactor(self, i: int, j: int):
        coeff = 1 if (i + j) % 2 == 0 else -1
        submatrix = Matrix(self.rows - 1, self.cols - 1)
        for row in range(submatrix.rows):
            for col in range(submatrix.cols):
                submatrix[row, col] = self[
                    row + 1 if row >= i else row,
                    col + 1 if col >= j else col
                ]
        return coeff * submatrix.determinant()

    def __str__(self):
        acc = ""
        for i in range(self.rows * self.cols):
            acc += f"{self.storage[i]:.0f}"
            acc += "\n" if i % self.cols == self.cols - 1 else "\t"
        return acc

    def __getitem__(self, pos: (int, int)):
        row, col = pos
        return self.storage[row * self.cols + col]

    def __setitem__(self, pos: (int, int), value: int):
        row, col = pos
        self.storage[row * self.cols + col] = value

    def _mul_indices(lhs, rhs, row, col) -> int:
        sum = 0
        for i in range(lhs.cols):
            sum += lhs[row, i] * rhs[i, col]
        return sum

    def __mul__(lhs, rhs):
        assert(lhs.cols == rhs.rows)
        result = Matrix(lhs.rows, rhs.cols)
        for row in range(result.rows):
            for col in range(result.cols):
                result[row, col] = lhs._mul_indices(rhs, row, col)
        return result

    def __truediv__(self, factor):
        result = Matrix(self.rows, self.cols)
        result.storage = [x / factor for x in self.storage]
        return result


def create_key(msg: str) -> Matrix:
    size = ceil(sqrt(len(msg)))
    matrix = Matrix(size, size)
    matrix.fill(msg)
    return matrix


def create_message(msg: str, cols: int) -> Matrix:
    matrix = Matrix(ceil(len(msg) / cols), cols)
    matrix.fill(msg)
    return matrix


if __name__ == "__main__":
    if len(argv) == 2 and argv[1] == "-h":
        print("""USAGE
    ./103cipher message key flag

DESCRIPTION
    message     a message, made of ASCII characters
    key         the encryption key, made of ASCII characters
    flag        0 for the message to be encrypted, 1 to be decrypted""")
        exit(0)
    if len(argv) != 4:
        print("Usage: ./103cipher message key flag")
        exit(84)
    message = argv[1]
    key = argv[2]
    flag = argv[3]
    keym = create_key(key)
    if flag == "0":
        print("Key matrix:")
        print(keym)
        msg = create_message(message, keym.cols)
        encrypted = msg * keym
        print("Encrypted message:")
        print(" ".join(map(lambda x: str(x), encrypted.storage)))
    elif flag == "1":
        print("Key matrix:")
        keyd = keym.inverse()
        if keyd is None:
            print("Not inversible sowwy")
            exit(84)
        print(keyd)
        integers = list(map(float, message.split(" ")))
        encrypted = Matrix(len(integers) // keym.cols, keym.cols)
        encrypted.storage = integers
        decrypted = encrypted * keyd
        print("Decrypted message:")
        print("".join(map(lambda x: chr(round(x)) if round(x) != 0 else '', decrypted.storage)))
    else:
        print("Flag must be 0 (encrypt) or 1 (decrypt)")
        exit(84)
